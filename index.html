<!DOCTYPE html><!DOCTYPE html>

<html><html>

<head><head>

    <meta charset="UTF-8">    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Sydney Meshcore Network Map</title>    <title>Sydney Meshcore Network Map</title>

        

    <!-- Leaflet CSS -->    <!-- Leaflet CSS -->

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"/>    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"/>          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="

    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css"/>          crossorigin=""/>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css"/>    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>    <style>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css"/>        * {

                margin: 0;

    <style>            padding: 0;

        * {            box-sizing: border-box;

            margin: 0;        }

            padding: 0;        html, body {

            box-sizing: border-box;            width: 100%;

        }            height: 100%;

                    overflow: hidden;

        html, body {            position: fixed;

            width: 100%;        }

            height: 100%;        #map {

            margin: 0;            position: fixed;

            padding: 0;            top: 0;

            overflow: hidden;            left: 0;

            position: fixed;            right: 0;

        }            bottom: 0;

                    width: 100%;

        #map {            height: 100%;

            position: fixed;        }

            top: 0;        #loading {

            left: 0;            position: fixed;

            right: 0;            top: 50%;

            bottom: 0;            left: 50%;

            width: 100%;            transform: translate(-50%, -50%);

            height: 100%;            background: rgba(0, 0, 0, 0.85);

            overflow: hidden;            color: white;

        }            padding: 30px 50px;

                    border-radius: 10px;

        /* Hide scrollbars */            font-family: Arial, sans-serif;

        ::-webkit-scrollbar {            font-size: 18px;

            width: 0px;            z-index: 10000;

            height: 0px;            text-align: center;

            display: none;        }

        }        .spinner {

                    border: 4px solid #f3f3f3;

        * {            border-top: 4px solid #667eea;

            scrollbar-width: none;            border-radius: 50%;

            -ms-overflow-style: none;            width: 40px;

        }            height: 40px;

                    animation: spin 1s linear infinite;

        /* Popup visibility */            margin: 20px auto 0;

        .leaflet-popup {        }

            z-index: 10000 !important;        @keyframes spin {

        }            0% { transform: rotate(0deg); }

                    100% { transform: rotate(360deg); }

        .leaflet-popup-pane {        }

            z-index: 10000 !important;        #error {

        }            display: none;

                    position: fixed;

        /* Path visibility control */            top: 50%;

        .leaflet-interactive.path-hidden {            left: 50%;

            display: none !important;            transform: translate(-50%, -50%);

            visibility: hidden !important;            background: rgba(255, 0, 0, 0.9);

            opacity: 0 !important;            color: white;

        }            padding: 30px 50px;

                    border-radius: 10px;

        .leaflet-interactive.path-visible {            font-family: Arial, sans-serif;

            display: block !important;            z-index: 10001;

            visibility: visible !important;            text-align: center;

            opacity: 1 !important;            max-width: 80%;

        }        }

            </style>

        /* Info panel styling */</head>

        #info-panel {<body>

            position: fixed;    <div id="loading">

            top: 10px;        <div>Loading Network Map Data...</div>

            left: 50px;        <div class="spinner"></div>

            width: 320px;    </div>

            max-height: 90vh;    <div id="error"></div>

            overflow-y: auto;    <div id="map"></div>

            background-color: white;

            border: 2px solid grey;    <!-- Leaflet JavaScript -->

            z-index: 9999;    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"

            font-size: 14px;            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="

            padding: 10px;            crossorigin=""></script>

            border-radius: 5px;    

            box-shadow: 2px 2px 6px rgba(0,0,0,0.3);    <script>

        }        // Global variables

                window.map_obj = null;

        /* Hide map controls */        window.networkData = null;

        .leaflet-control-zoom,        window.coverageDataCache = {};

        .leaflet-control-fullscreen,        window.coverageCircles = {};

        .leaflet-control-layers {        window.coverageCirclesVisible = false;

            display: none !important;        window.currentFilter = null;

        }        

                // Load the network data JSON

        /* Mobile responsive design */        function loadNetworkData() {

        @media (max-width: 768px) {            fetch('network_map_data.json')

            #info-panel {                .then(response => {

                top: 60px;                    if (!response.ok) {

                left: 10px;                        throw new Error('Failed to load network data: ' + response.statusText);

                right: 10px;                    }

                width: auto;                    return response.json();

                max-width: calc(100vw - 20px);                })

                max-height: 60vh;                .then(data => {

                font-size: 14px;                    console.log('Network data loaded successfully');

                padding: 12px;                    window.networkData = data;

                display: none;                    document.getElementById('loading').style.display = 'none';

            }                    initializeMap();

                            })

            #info-panel h4 {                .catch(error => {

                font-size: 18px !important;                    console.error('Error loading network data:', error);

                margin: 8px 0 !important;                    document.getElementById('loading').style.display = 'none';

            }                    document.getElementById('error').style.display = 'block';

                                document.getElementById('error').innerHTML = 

            #info-panel p {                        '<h2>⚠️ Error Loading Map Data</h2>' +

                font-size: 13px !important;                        '<p style="margin-top: 10px;">' + error.message + '</p>' +

                margin: 4px 0 !important;                        '<p style="margin-top: 10px; font-size: 14px;">Please ensure network_map_data.json is available.</p>';

            }                });

                    }

            .leaflet-marker-icon > div > div:last-child {        

                display: none !important;        // Initialize the map once data is loaded

            }        function initializeMap() {

        }            const data = window.networkData;

                    

        @media (max-width: 480px) {            // Calculate center from nodes

            #info-panel {            let center_lat, center_lon;

                max-height: 55vh;            if (data.nodes && Object.keys(data.nodes).length > 0) {

                font-size: 13px;                const lats = [];

            }                const lons = [];

                            for (const node of Object.values(data.nodes)) {

            #info-panel h4 {                    if (node.lat && node.lon) {

                font-size: 16px !important;                        lats.push(node.lat);

            }                        lons.push(node.lon);

        }                    }

                        }

        /* Loading overlay */                if (lats.length > 0) {

        #loading-overlay {                    center_lat = lats.reduce((a, b) => a + b, 0) / lats.length;

            position: fixed;                    center_lon = lons.reduce((a, b) => a + b, 0) / lons.length;

            top: 0;                } else {

            left: 0;                    center_lat = -33.8688;

            right: 0;                    center_lon = 151.2093;

            bottom: 0;                }

            background: rgba(255, 255, 255, 0.9);            } else {

            display: flex;                center_lat = -33.8688;

            align-items: center;                center_lon = 151.2093;

            justify-content: center;            }

            z-index: 10000;            

            flex-direction: column;            // Create the map

        }            window.map_obj = L.map('map', {

                        center: [center_lat, center_lon],

        .spinner {                zoom: 11,

            border: 4px solid #f3f3f3;                zoomControl: true,

            border-top: 4px solid #3388ff;                maxZoom: 18

            border-radius: 50%;            });

            width: 50px;            

            height: 50px;            // Add tile layer

            animation: spin 1s linear infinite;            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {

        }                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',

                        maxZoom: 18

        @keyframes spin {            }).addTo(window.map_obj);

            0% { transform: rotate(0deg); }            

            100% { transform: rotate(360deg); }            console.log('Map initialized at:', center_lat, center_lon);

        }            

    </style>            // Now render all map elements

</head>            renderMapElements();

<body>        }

    <!-- Loading overlay -->        

    <div id="loading-overlay">        // Render all map elements (nodes, links, etc.)

        <div class="spinner"></div>        function renderMapElements() {

        <p style="margin-top: 20px; font-size: 16px; color: #333;">Loading network map...</p>            console.log('Rendering map elements...');

    </div>            

                // This is where we'll add nodes, links, coverage, etc.

    <!-- Map container -->            // For now, just show a simple message

    <div id="map"></div>            const data = window.networkData;

                console.log('Loaded data contains:');

    <!-- Info panel -->            console.log('  - Nodes:', Object.keys(data.nodes || {}).length);

    <div id="info-panel">            console.log('  - Links:', (data.links || []).length);

        <div id="stats-view">            console.log('  - Coverage data:', Object.keys(data.coverage || {}).length);

            <h4 style="margin: 0 0 5px 0;">Sydney Meshcore Mesh Map</h4>            

            <p style="margin: 0; font-size: 12px;">            // Add markers for nodes

                <b>Generated:</b> <span id="generated-time">Loading...</span><br>            if (data.nodes) {

                <b>Nodes:</b> <span id="node-count">0</span>                 for (const [pubkey, node] of Object.entries(data.nodes)) {

                (<span id="gps-count">0</span> with GPS)<br>                    if (node.lat && node.lon) {

                <b>Links:</b> <span id="link-count">0</span><br>                        const marker = L.circleMarker([node.lat, node.lon], {

                <b>RF Packets:</b> <span id="packet-count">0</span>                            radius: 8,

            </p>                            fillColor: getNodeColor(node.type),

                                        color: '#fff',

            <hr style="margin: 10px 0;">                            weight: 2,

                                        opacity: 1,

            <h4 style="margin: 5px 0;">Node Types</h4>                            fillOpacity: 0.8

            <div id="node-types" style="font-size: 11px; margin: 5px 0;">                        }).addTo(window.map_obj);

                <label style="display: block; margin: 5px 0; cursor: pointer;">                        

                    <input type="checkbox" id="show-users" checked onchange="toggleNodeType('users', this.checked)" style="transform: scale(0.9);">                        marker.bindPopup('<b>' + (node.name || 'Unknown') + '</b><br>Type: ' + getNodeTypeName(node.type));

                    <span style="color: #3388ff;">● Users: <span id="user-count">0</span></span>                    }

                </label>                }

                <label style="display: block; margin: 5px 0; cursor: pointer;">            }

                    <input type="checkbox" id="show-repeaters" checked onchange="toggleNodeType('repeaters', this.checked)" style="transform: scale(0.9);">            

                    <span style="color: #ff3333;">● Repeaters: <span id="repeater-count">0</span></span>            // Add links

                </label>            if (data.links) {

                <label style="display: block; margin: 10px 0 5px 20px; cursor: pointer;">                for (const link of data.links) {

                    <input type="checkbox" id="filter-inactive-repeaters" onchange="toggleInactiveRepeaters(this.checked)" style="transform: scale(0.9);">                    // Find nodes by pubkey prefix

                    <span style="font-size: 10px;">Hide Inactive Repeaters</span>                    const fromNode = findNodeByPrefix(link.from_prefix);

                </label>                    const toNode = data.nodes[link.to_pubkey];

            </div>                    

                                if (fromNode && toNode && fromNode.lat && fromNode.lon && toNode.lat && toNode.lon) {

            <hr style="margin: 10px 0;">                        const snr = link.snr || 0;

                                    const color = snrToColor(snr);

            <h4 style="margin: 5px 0;">Link Filters</h4>                        

            <div style="font-size: 11px; margin: 5px 0;">                        L.polyline([

                <label style="display: block; margin: 5px 0; cursor: pointer;">                            [fromNode.lat, fromNode.lon],

                    <input type="checkbox" id="show-links" checked onchange="toggleLinks(this.checked)" style="transform: scale(0.9);">                            [toNode.lat, toNode.lon]

                    Show RF Links                        ], {

                </label>                            color: color,

                <label style="display: block; margin: 5px 0; cursor: pointer;">                            weight: 3,

                    <input type="checkbox" id="show-coverage" onchange="toggleCoverage(this.checked)" style="transform: scale(0.9);">                            opacity: 0.6

                    Show Coverage Zones                        }).addTo(window.map_obj).bindPopup(

                </label>                            '<b>Link:</b> ' + (fromNode.name || '?') + ' → ' + (toNode.name || '?') + 

            </div>                            '<br>SNR: ' + snr + ' dB'

                                    );

            <hr style="margin: 10px 0;">                    }

                            }

            <button onclick="resetFilters()" style="width: 100%; padding: 8px; font-size: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">            }

                Reset All Filters            

            </button>            console.log('Map elements rendered');

        </div>        }

    </div>        

            // Helper functions

    <!-- Leaflet JS -->        function getNodeColor(type) {

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>            const colors = {

    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>                0: '#808080', // Unknown - gray

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>                1: '#3388ff', // User - blue

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>                2: '#ff3333', // Repeater - red

                    3: '#33cc33'  // Room Server - green

    <script>            };

        // Global variables            return colors[type] || '#808080';

        let map = null;        }

        let mapData = null;        

        let markerLayer = null;        function getNodeTypeName(type) {

        let linkLayer = null;            const names = {

        let coverageLayer = null;                0: 'Unknown',

        let nodeMarkers = {};                1: 'User',

        let linkLines = {};                2: 'Repeater',

        let coverageCircles = {};                3: 'Room Server'

                    };

        // Initialize map            return names[type] || 'Unknown';

        function initMap() {        }

            map = L.map('map', {        

                center: [-33.75, 151.1],        function snrToColor(snr) {

                zoom: 10,            const clamped = Math.max(-20, Math.min(5, snr));

                zoomControl: false,            const normalized = (clamped + 20) / 25.0;

                attributionControl: true            

            });            let r, g;

                        if (normalized < 0.5) {

            // Add tile layer                const t = normalized * 2;

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {                r = 255;

                attribution: '© OpenStreetMap contributors',                g = Math.floor(255 * t);

                maxZoom: 19            } else {

            }).addTo(map);                const t = (normalized - 0.5) * 2;

                            r = Math.floor(255 * (1 - t));

            // Create feature groups                g = 255;

            markerLayer = L.featureGroup().addTo(map);            }

            linkLayer = L.featureGroup().addTo(map);            

            coverageLayer = L.featureGroup();            return '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + '00';

                    }

            console.log('Map initialized');        

        }        function findNodeByPrefix(prefix) {

                    if (!window.networkData || !window.networkData.nodes) return null;

        // Load network data            for (const [pubkey, node] of Object.entries(window.networkData.nodes)) {

        async function loadNetworkData() {                if (pubkey.startsWith(prefix)) {

            try {                    return node;

                const response = await fetch('network_map_data.json');                }

                if (!response.ok) {            }

                    throw new Error(`HTTP error! status: ${response.status}`);            return null;

                }        }

                mapData = await response.json();        

                console.log('Network data loaded:', mapData);        // Start loading data when page loads

                return mapData;        window.addEventListener('load', loadNetworkData);

            } catch (error) {    </script>

                console.error('Error loading network data:', error);</body>

                document.getElementById('loading-overlay').innerHTML = </html>

                    '<div style="text-align: center;"><h3 style="color: red;">Error Loading Map Data</h3>' +
                    '<p>Please ensure network_map_data.json is present.</p>' +
                    '<p style="font-size: 12px; color: #666;">' + error.message + '</p></div>';
                throw error;
            }
        }
        
        // Update statistics panel
        function updateStatistics() {
            if (!mapData) return;
            
            const metadata = mapData.metadata || {};
            const nodes = mapData.nodes || {};
            const links = mapData.links || [];
            
            document.getElementById('generated-time').textContent = mapData.generated_readable || 'Unknown';
            document.getElementById('node-count').textContent = Object.keys(nodes).length;
            document.getElementById('link-count').textContent = links.length;
            
            // Count nodes with GPS
            const gpsCount = Object.values(nodes).filter(n => n.lat && n.lon && n.lat !== 0 && n.lon !== 0).length;
            document.getElementById('gps-count').textContent = gpsCount;
            
            // Count packet transmissions
            const packetCount = metadata.rf_packet_count || 0;
            document.getElementById('packet-count').textContent = packetCount;
            
            // Count node types
            const userCount = Object.values(nodes).filter(n => n.type === 1).length;
            const repeaterCount = Object.values(nodes).filter(n => n.type === 2).length;
            document.getElementById('user-count').textContent = userCount;
            document.getElementById('repeater-count').textContent = repeaterCount;
        }
        
        // Create marker for node
        function createNodeMarker(pubkey, node) {
            const lat = node.lat;
            const lon = node.lon;
            
            if (!lat || !lon || lat === 0 || lon === 0) return null;
            
            const name = node.name || 'Unknown';
            const type = node.type || 1;
            const estimated = node.estimated || false;
            
            // Determine color based on type
            let color = '#3388ff'; // User (blue)
            if (type === 2) color = '#ff3333'; // Repeater (red)
            
            // Create custom div icon
            const initials = name.substring(0, 2).toUpperCase();
            const borderStyle = estimated ? 'dashed' : 'solid';
            const opacity = estimated ? 0.7 : 1;
            
            const iconHtml = `
                <div style="display: flex; align-items: center; white-space: nowrap; cursor: pointer;"
                     onclick="showNodePopup('${pubkey}')">
                    <div style="
                        width: 36px;
                        height: 36px;
                        min-width: 36px;
                        min-height: 36px;
                        border-radius: 50%;
                        background-color: ${color};
                        border: 3px ${borderStyle} #222222;
                        opacity: ${opacity};
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 14px;
                        font-weight: bold;
                        color: white;
                        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                        flex-shrink: 0;
                    ">
                        ${initials}
                    </div>
                    <div style="
                        font-size: 11px;
                        font-weight: 600;
                        color: #222222;
                        margin-left: 8px;
                        text-shadow: 
                            -1px -1px 1px white,
                            1px -1px 1px white,
                            -1px 1px 1px white,
                            1px 1px 1px white;
                    ">
                        ${name}${estimated ? ' <i>(est.)</i>' : ''}
                    </div>
                </div>
            `;
            
            const marker = L.marker([lat, lon], {
                icon: L.divIcon({
                    html: iconHtml,
                    iconSize: [null, null],
                    iconAnchor: [18, 18],
                    className: 'empty'
                })
            });
            
            // Create popup content
            const popupContent = createNodePopupContent(pubkey, node);
            marker.bindPopup(popupContent, { maxWidth: 400 });
            
            // Add tooltip
            marker.bindTooltip(name + (estimated ? ' (estimated)' : ''), { sticky: true });
            
            return marker;
        }
        
        // Create popup content for node
        function createNodePopupContent(pubkey, node) {
            const name = node.name || 'Unknown';
            const type = node.type === 2 ? 'Repeater' : 'User';
            const lat = node.lat || 0;
            const lon = node.lon || 0;
            
            let html = `
                <div style="font-family: Arial; min-width: 350px; max-height: 600px; overflow-y: auto;">
                    <h3 style="margin: 0 0 15px 0; color: #333; border-bottom: 2px solid #4CAF50; padding-bottom: 5px;">
                        ${name}
                    </h3>
                    
                    <div style="margin-bottom: 15px;">
                        <h4 style="margin: 5px 0; color: #666; font-size: 14px;">Basic Information</h4>
                        <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
                            <tr style="background: #f5f5f5;">
                                <td style="padding: 4px 8px; font-weight: bold; width: 40%;">Type:</td>
                                <td style="padding: 4px 8px;">${type}</td>
                            </tr>
                        </table>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <h4 style="margin: 5px 0; color: #666; font-size: 14px;">Location</h4>
                        <table style="width: 100%; font-size: 12px; border-collapse: collapse;">
                            <tr style="background: #f5f5f5;">
                                <td style="padding: 4px 8px; font-weight: bold; width: 40%;">Latitude:</td>
                                <td style="padding: 4px 8px; font-family: monospace;">${lat.toFixed(6)}</td>
                            </tr>
                            <tr>
                                <td style="padding: 4px 8px; font-weight: bold;">Longitude:</td>
                                <td style="padding: 4px 8px; font-family: monospace;">${lon.toFixed(6)}</td>
                            </tr>
                        </table>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <h4 style="margin: 5px 0; color: #666; font-size: 14px;">Public Key</h4>
                        <div style="background: #f0f0f0; padding: 8px; border-radius: 4px; word-break: break-all; font-family: monospace; font-size: 10px;">
                            ${pubkey}
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        // Create link line between two nodes
        function createLinkLine(link) {
            const fromPubkey = link.from_pubkey;
            const toPubkey = link.to_pubkey;
            
            const fromNode = mapData.nodes[fromPubkey];
            const toNode = mapData.nodes[toPubkey];
            
            if (!fromNode || !toNode) return null;
            if (!fromNode.lat || !fromNode.lon || !toNode.lat || !toNode.lon) return null;
            
            const snr = link.snr || 0;
            
            // Color based on SNR quality
            let color = '#00ff00'; // Good (green)
            if (snr < -10) color = '#ff0000'; // Bad (red)
            else if (snr < 0) color = '#ffaa00'; // Moderate (orange)
            
            const line = L.polyline([
                [fromNode.lat, fromNode.lon],
                [toNode.lat, toNode.lon]
            ], {
                color: color,
                weight: 2,
                opacity: 0.6
            });
            
            // Add popup with link info
            const popupContent = `
                <div style="font-size: 12px;">
                    <b>Link:</b> ${fromNode.name} → ${toNode.name}<br>
                    <b>SNR:</b> ${snr.toFixed(2)} dB<br>
                    <b>Distance:</b> ${calculateDistance(fromNode.lat, fromNode.lon, toNode.lat, toNode.lon).toFixed(2)} km
                </div>
            `;
            line.bindPopup(popupContent);
            
            return line;
        }
        
        // Calculate distance between two points (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Render all nodes on map
        function renderNodes() {
            if (!mapData || !mapData.nodes) return;
            
            markerLayer.clearLayers();
            nodeMarkers = {};
            
            Object.keys(mapData.nodes).forEach(pubkey => {
                const node = mapData.nodes[pubkey];
                const marker = createNodeMarker(pubkey, node);
                if (marker) {
                    marker.addTo(markerLayer);
                    nodeMarkers[pubkey] = marker;
                }
            });
            
            console.log(`Rendered ${Object.keys(nodeMarkers).length} node markers`);
        }
        
        // Render all links on map
        function renderLinks() {
            if (!mapData || !mapData.links) return;
            
            linkLayer.clearLayers();
            linkLines = {};
            
            mapData.links.forEach((link, index) => {
                const line = createLinkLine(link);
                if (line) {
                    line.addTo(linkLayer);
                    linkLines[index] = line;
                }
            });
            
            console.log(`Rendered ${Object.keys(linkLines).length} link lines`);
        }
        
        // Render coverage zones
        function renderCoverage() {
            if (!mapData || !mapData.coverage) return;
            
            coverageLayer.clearLayers();
            coverageCircles = {};
            
            // Coverage data is per-repeater
            Object.keys(mapData.coverage).forEach(pubkey => {
                const node = mapData.nodes[pubkey];
                if (!node || !node.lat || !node.lon) return;
                
                // Simple coverage circle (you can enhance this with actual coverage data)
                const circle = L.circle([node.lat, node.lon], {
                    color: '#ff3333',
                    fillColor: '#ff3333',
                    fillOpacity: 0.1,
                    radius: 20000 // 20km radius
                });
                
                circle.addTo(coverageLayer);
                coverageCircles[pubkey] = circle;
            });
            
            console.log(`Rendered ${Object.keys(coverageCircles).length} coverage zones`);
        }
        
        // Toggle functions for filters
        function toggleNodeType(type, show) {
            // Filter implementation
            console.log(`Toggle ${type}: ${show}`);
        }
        
        function toggleInactiveRepeaters(hide) {
            console.log(`Toggle inactive repeaters: ${hide}`);
        }
        
        function toggleLinks(show) {
            if (show) {
                linkLayer.addTo(map);
            } else {
                map.removeLayer(linkLayer);
            }
        }
        
        function toggleCoverage(show) {
            if (show) {
                coverageLayer.addTo(map);
            } else {
                map.removeLayer(coverageLayer);
            }
        }
        
        function resetFilters() {
            document.getElementById('show-users').checked = true;
            document.getElementById('show-repeaters').checked = true;
            document.getElementById('filter-inactive-repeaters').checked = false;
            document.getElementById('show-links').checked = true;
            document.getElementById('show-coverage').checked = false;
            
            toggleLinks(true);
            toggleCoverage(false);
        }
        
        function showNodePopup(pubkey) {
            const marker = nodeMarkers[pubkey];
            if (marker) {
                marker.openPopup();
            }
        }
        
        // Main initialization
        async function init() {
            try {
                initMap();
                await loadNetworkData();
                updateStatistics();
                renderNodes();
                renderLinks();
                renderCoverage();
                
                // Hide loading overlay
                document.getElementById('loading-overlay').style.display = 'none';
                
                // Fit map to markers
                if (Object.keys(nodeMarkers).length > 0) {
                    map.fitBounds(markerLayer.getBounds(), { padding: [50, 50] });
                }
                
                console.log('Map initialization complete');
            } catch (error) {
                console.error('Initialization error:', error);
            }
        }
        
        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
